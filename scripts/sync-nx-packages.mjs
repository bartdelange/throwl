#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();
const LIBS_DIR = path.join(ROOT, 'libs');
const ROOT_PRESET = path.join(ROOT, 'jest.preset.js');

const CONDITION = '@throwl/source';

function readJson(file) {
  return JSON.parse(fs.readFileSync(file, 'utf8'));
}
function writeJson(file, obj) {
  fs.writeFileSync(file, JSON.stringify(obj, null, 2) + '\n', 'utf8');
}
function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}
function exists(p) {
  return fs.existsSync(p);
}
function listFilesRec(dir, filename) {
  const out = [];
  const stack = [dir];
  while (stack.length) {
    const cur = stack.pop();
    const entries = fs.readdirSync(cur, { withFileTypes: true });
    for (const e of entries) {
      const full = path.join(cur, e.name);
      if (e.isDirectory()) stack.push(full);
      else if (e.isFile() && e.name === filename) out.push(full);
    }
  }
  return out;
}
function findProjectJsonFiles() {
  if (!exists(LIBS_DIR)) return [];
  return listFilesRec(LIBS_DIR, 'project.json');
}
function normalizeSlashes(p) {
  return p.replace(/\\/g, '/');
}

function ensureLibPackageJson({ projectJsonPath, importPath }) {
  const projectRoot = path.dirname(projectJsonPath);
  const pkgPath = path.join(projectRoot, 'package.json');

  const desired = {
    name: importPath,
    version: '0.0.0',
    private: true,
    types: './src/index.ts',
    exports: {
      '.': {
        types: './src/index.ts',
        [CONDITION]: './src/index.ts',
      },
    },
  };

  if (!exists(pkgPath)) {
    writeJson(pkgPath, desired);
    return { created: true, updated: false, pkgPath };
  }

  const current = readJson(pkgPath);

  // Keep any extra fields the user might add, but enforce key bits.
  current.name = importPath;
  current.private = true;
  current.version = current.version ?? '0.0.0';
  current.types = './src/index.ts';
  current.exports = current.exports ?? {};
  current.exports['.'] = current.exports['.'] ?? {};
  current.exports['.'].types = './src/index.ts';
  current.exports['.'][CONDITION] = './src/index.ts';

  writeJson(pkgPath, current);
  return { created: false, updated: true, pkgPath };
}

function ensureIndexTs(projectJsonPath) {
  const projectRoot = path.dirname(projectJsonPath);
  const indexPath = path.join(projectRoot, 'src', 'index.ts');
  if (exists(indexPath)) return false;
  ensureDir(path.dirname(indexPath));
  fs.writeFileSync(indexPath, `// Public API\n`, 'utf8');
  return true;
}

function generateJestPreset(moduleNameMapperEntries) {
  // Keep it deterministic (sorted)
  const keys = Object.keys(moduleNameMapperEntries).sort();

  const lines = [];
  lines.push(`const nxPreset = require('@nx/jest/preset').default;`);
  lines.push('');
  lines.push(`/**`);
  lines.push(` * AUTO-GENERATED by scripts/sync-nx-packages.mjs`);
  lines.push(` * Do not edit manually.`);
  lines.push(` */`);
  lines.push(`module.exports = {`);
  lines.push(`  ...nxPreset,`);
  lines.push(`  moduleNameMapper: {`);
  lines.push(`    ...(nxPreset.moduleNameMapper || {}),`);
  lines.push('');

  for (const k of keys) {
    lines.push(
      `    ${JSON.stringify(k)}: ${JSON.stringify(moduleNameMapperEntries[k])},`,
    );
  }

  lines.push(`  },`);
  lines.push(`};`);
  lines.push('');

  fs.writeFileSync(ROOT_PRESET, lines.join('\n'), 'utf8');
}

function main() {
  const projectFiles = findProjectJsonFiles();

  if (projectFiles.length === 0) {
    console.error('No libs/**/project.json found. Nothing to sync.');
    process.exit(1);
  }

  let pkgCreated = 0;
  let pkgUpdated = 0;
  let indexCreated = 0;

  // Build moduleNameMapper from importPath => <rootDir>/<projectRoot>/src/index.ts
  const mapper = {};

  for (const pj of projectFiles) {
    const proj = readJson(pj);

    // Nx project.json uses "name" as project name; importPath may or may not exist.
    // In your setup: project.json name is the package name (e.g. "@throwl/shared-ui").
    // Prefer importPath if present, else fallback to name if it looks like @throwl/*
    const importPath =
      proj.importPath ||
      (typeof proj.name === 'string' && proj.name.startsWith('@throwl/')
        ? proj.name
        : null);

    if (!importPath) continue;

    // Ensure per-lib package.json exports exist
    const res = ensureLibPackageJson({ projectJsonPath: pj, importPath });
    if (res.created) pkgCreated++;
    else if (res.updated) pkgUpdated++;

    // Optional: ensure src/index.ts exists
    if (ensureIndexTs(pj)) indexCreated++;

    // Add jest mapping (exact match only, no deep imports)
    const projectRoot = path.dirname(pj);
    const relIndex = normalizeSlashes(
      path.relative(ROOT, path.join(projectRoot, 'src', 'index.ts')),
    );
    mapper[`^${importPath.replace('/', '\\/')}$`] = `<rootDir>/${relIndex}`;
  }

  generateJestPreset(mapper);

  console.log(
    `✅ Synced libs: package.json exports (created ${pkgCreated}, updated ${pkgUpdated})`,
  );
  console.log(`✅ Ensured src/index.ts (created ${indexCreated})`);
  console.log(
    `✅ Regenerated jest.preset.js with ${Object.keys(mapper).length} moduleNameMapper entries`,
  );
}

main();
